---
description: KISS-style JavaScript/TypeScript coding preferences for React/Next.js
globs: *.js, *.jsx, *.ts, *.tsx, **/*.js, **/*.jsx, **/*.ts, **/*.tsx
alwaysApply: false
---
user_rules:
  - id: general_philosophy
    summary: "Keep it simple and practical"
    description: |
      â€¢ Follow KISS principles â€” avoid over-engineering
      â€¢ Prefer functional patterns over complex OOP
      â€¢ Simplicity and clarity over theoretical perfection

  - id: typescript_usage
    summary: "TypeScript for clarity, not verbosity"
    description: |
      â€¢ Use explicit typing for function params and returns
      â€¢ Avoid overly complex generic types
        âœ… function fetchUser(id: string): Promise<User>
        ðŸš« function fetchUser<T extends BaseEntity>(id: string): Promise<ExtractType<T>>

  - id: react_patterns
    summary: "Modern React with hooks"
    description: |
      â€¢ Use functional components with hooks â€” no class components
      â€¢ Keep components focused and single-purpose
      â€¢ Extract complex logic into custom hooks
      â€¢ Use 'use client' directive only when needed (Next.js)

  - id: state_management
    summary: "Simple state, clear data flow"
    description: |
      â€¢ Use useCallback/useMemo only when performance matters
      â€¢ Keep state close to where it's used
      â€¢ Avoid prop drilling â€” lift state only when needed

  - id: naming_conventions
    summary: "Clear, consistent naming"
    description: |
      â€¢ Prefix event handlers with 'handle': handleClick, handleSubmit
      â€¢ Prefix booleans with 'is', 'has', 'can': isLoading, hasError
      â€¢ Keep names short but descriptive
        âœ… const isLoading = true; const handleClick = () => {};
        ðŸš« const loadingStatus = true; const clickHandler = () => {};

  - id: api_data_fetching
    summary: "Clean API calls"
    description: |
      â€¢ Create dedicated API client modules (e.g., lib/api/)
      â€¢ Type API responses with interfaces
      â€¢ Keep API logic separate from components
        âœ… export async function fetchTopics(): Promise<Topic[]> { }

  - id: comments_documentation
    summary: "Explain why, not what"
    description: |
      â€¢ Comment only for non-obvious logic or reasoning
      â€¢ Let code be self-documenting through clear naming
        ðŸš« // Set loading to true
        âœ… // Prevent race condition from concurrent requests

  - id: error_handling
    summary: "Handle errors properly"
    description: |
      â€¢ Always use try/catch for async operations
      â€¢ Log errors with context: console.error('Failed to load topics:', error)

  - id: hooks_best_practices
    summary: "Custom hooks for reusable logic"
    description: |
      â€¢ Extract complex stateful logic into custom hooks
      â€¢ Name with 'use' prefix: useAuth, useVoiceCall
      â€¢ Use refs for mutable values that shouldn't trigger re-renders

  - id: websocket_realtime
    summary: "Handle WebSocket connections carefully"
    description: |
      â€¢ Use refs to store WebSocket instances and callbacks
      â€¢ Clean up connections in useEffect cleanup
      â€¢ Handle reconnection and error states explicitly

  - id: example_code_style
    summary: "Example: preferred vs avoid"
    description: |
      âœ… Preferred
      ```typescript
      export default function TopicCard({ topic, onSelect }: Props) {
        const [isHovered, setIsHovered] = useState(false);

        const handleClick = () => {
          onSelect(topic.id);
        };

        return (
          <button
            onClick={handleClick}
            onMouseEnter={() => setIsHovered(true)}
            className={`card ${isHovered ? 'card-hover' : ''}`}
          >
            <h3>{topic.name}</h3>
          </button>
        );
      }
      ```

      ðŸš« Avoid
      ```typescript
      export default function TopicCardComponent(props: TopicCardComponentProps) {
        const [isCurrentlyBeingHoveredByMouse, setIsCurrentlyBeingHoveredByMouse] = useState<boolean>(false);

        const handleTopicCardClickEvent = () => {
          props.onTopicSelectionCallback(props.topicData.identifier);
        };

        return (
          <button
            onClick={handleTopicCardClickEvent}
            onMouseEnter={() => setIsCurrentlyBeingHoveredByMouse(true)}
          >
            <h3>{props.topicData.name}</h3>
          </button>
        );
      }
      ```
